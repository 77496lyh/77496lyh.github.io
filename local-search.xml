<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>大物第十章作业答案</title>
    <link href="/2020/09/23/%E5%A4%A7%E7%89%A9%E4%BD%9C%E4%B8%9A%20%E7%AC%AC%E5%8D%81%E7%AB%A0/"/>
    <url>/2020/09/23/%E5%A4%A7%E7%89%A9%E4%BD%9C%E4%B8%9A%20%E7%AC%AC%E5%8D%81%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><h3 id="10-1-D"><a href="#10-1-D" class="headerlink" title="10-1 D"></a>10-1 D</h3><h3 id="10-2-B"><a href="#10-2-B" class="headerlink" title="10-2 B"></a>10-2 B</h3><h3 id="10-3-A"><a href="#10-3-A" class="headerlink" title="10-3 A"></a>10-3 A</h3><h3 id="10-4-B"><a href="#10-4-B" class="headerlink" title="10-4 B"></a>10-4 B</h3><h3 id="10-5-D"><a href="#10-5-D" class="headerlink" title="10-5 D"></a>10-5 D</h3><h3 id="10-6"><a href="#10-6" class="headerlink" title="10-6"></a>10-6</h3><p><img src="https://img-blog.csdnimg.cn/20200923124724539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3M3NzQ5NmF6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200923124732959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3M3NzQ5NmF6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="10-8"><a href="#10-8" class="headerlink" title="10-8"></a>10-8</h3><p><img src="https://img-blog.csdnimg.cn/20200923130912472.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3M3NzQ5NmF6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200923130923777.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3M3NzQ5NmF6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="10-9"><a href="#10-9" class="headerlink" title="10-9"></a>10-9</h3><p><img src="https://img-blog.csdnimg.cn/20200923130942659.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3M3NzQ5NmF6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200923131000875.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3M3NzQ5NmF6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="10-10"><a href="#10-10" class="headerlink" title="10-10"></a>10-10</h3><p><img src="https://img-blog.csdnimg.cn/2020092313102395.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3M3NzQ5NmF6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200923131030120.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3M3NzQ5NmF6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="10-11"><a href="#10-11" class="headerlink" title="10-11"></a>10-11</h3><p><img src="https://img-blog.csdnimg.cn/20200923131040901.PNG#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200923131048503.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3M3NzQ5NmF6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="10-12"><a href="#10-12" class="headerlink" title="10-12"></a>10-12</h3><p><img src="https://img-blog.csdnimg.cn/20200923131105135.PNG#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200923131111580.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3M3NzQ5NmF6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="10-13"><a href="#10-13" class="headerlink" title="10-13"></a>10-13</h3><p><img src="https://img-blog.csdnimg.cn/2020092313112297.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3M3NzQ5NmF6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200923131129520.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3M3NzQ5NmF6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="10-14"><a href="#10-14" class="headerlink" title="10-14"></a>10-14</h3><p><img src="https://img-blog.csdnimg.cn/20200923131255137.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200923131302412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3M3NzQ5NmF6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="10-15"><a href="#10-15" class="headerlink" title="10-15"></a>10-15</h3><p><img src="https://img-blog.csdnimg.cn/20200923132346538.JPG#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200923132353632.JPG#pic_center" alt="在这里插入图片描述"></p><h6 id="PS-原题还要求磁矩"><a href="#PS-原题还要求磁矩" class="headerlink" title="PS:原题还要求磁矩"></a>PS:原题还要求磁矩</h6><h3 id="10-16"><a href="#10-16" class="headerlink" title="10-16"></a>10-16</h3><p><img src="https://img-blog.csdnimg.cn/20200923132405419.PNG#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200923132411270.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3M3NzQ5NmF6,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图及深度优先搜索（DFS）和广度优先搜索（BFS）</title>
    <link href="/2020/09/22/%E5%9B%BE%E5%8F%8A%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89/"/>
    <url>/2020/09/22/%E5%9B%BE%E5%8F%8A%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="1-图"><a href="#1-图" class="headerlink" title="1.图"></a>1.图</h1><h2 id="1-1图的种类"><a href="#1-1图的种类" class="headerlink" title="1.1图的种类"></a>1.1图的种类</h2><p>图由顶点和边组成，顶点代表对象。图大致上分成两种，边没有指向性的图叫做无向图，边具有指向性的图。我们可以给边附上属性，例如权值（cost），带有权值的图叫做网。<br><img src="https://img-blog.csdnimg.cn/20200316151107698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3M3NzQ5NmF6,size_16,color_FFFFFF,t_70" alt="1"></p><h2 id="1-2-连通图、非连通图、树和森林"><a href="#1-2-连通图、非连通图、树和森林" class="headerlink" title="1.2 连通图、非连通图、树和森林"></a>1.2 连通图、非连通图、树和森林</h2><p>无向图中顶点连接的边数叫做这个顶点的度，起点和重点重合的路径叫做圈，任意两点之间都有路径的无向图叫做连通图，没有圈的连通图叫做树，没有圈的非连通图叫做森林</p><h1 id="2-深度优先搜索（DFS）"><a href="#2-深度优先搜索（DFS）" class="headerlink" title="2.深度优先搜索（DFS）"></a>2.深度优先搜索（DFS）</h1><h2 id="2-1-基本思路"><a href="#2-1-基本思路" class="headerlink" title="2.1 基本思路"></a>2.1 基本思路</h2><p>DFS基于递归思想，以一个未被访问过的顶点作为起点，沿边走到一个未被标记的顶点，如果走到尽头，则返回上一顶点继续搜寻其他未被标记的顶点，直到从起始点可到达的所有顶点都被标记为止。如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020031620185739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3M3NzQ5NmF6,size_16,color_FFFFFF,t_70" alt="111"></p><h2 id="2-2-实现代码"><a href="#2-2-实现代码" class="headerlink" title="2.2 实现代码"></a>2.2 实现代码</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> j;    <span class="hljs-keyword">if</span> (i == n + <span class="hljs-number">1</span>)    &#123;        print();        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= n; j++)    &#123;        <span class="hljs-keyword">if</span> (b[j] == <span class="hljs-number">0</span>)        &#123;            a[i] = j;            b[j] = <span class="hljs-number">1</span>;            dfs(i + <span class="hljs-number">1</span>);            b[j] = <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre><h2 id="2-3-例题"><a href="#2-3-例题" class="headerlink" title="2.3 例题"></a>2.3 例题</h2><h5 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h5><p>已知 nnn 个整数 x1,x2,…,xnx_1,x_2,…,x_nx1​,x2​,…,xn​，以及111个整数kkk(k&lt;nk&lt;nk&lt;n)。从nnn个整数中任选kkk个整数相加，可分别得到一系列的和。例如当n=4,k=3n=4,k=3n=4,k=3,444个整数分别为3,7,12,193,7,12,193,7,12,19时，可得全部的组合与它们的和为：3+7+12=223+7+12=223+7+12=223+7+19=293+7+19=293+7+19=297+12+19=387+12+19=387+12+19=383+12+19=343+12+19=343+12+19=34。现在，要求你计算出和为素数共有多少种。例如上例，只有一种的和为素数：3+7+19=293+7+19=293+7+19=29。</p><h5 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h5><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isprime</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span></span>&#123;<span class="hljs-comment">//判断素数</span>    <span class="hljs-comment">/*0和1特判真的没啥用对这题</span><span class="hljs-comment">    吐槽：题中n的数据范围很奇怪，</span><span class="hljs-comment">    n还有可能=1.....那k&lt;n......</span><span class="hljs-comment">    */</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i*i&lt;=a;i++)<span class="hljs-comment">//不想用sqrt，还要头文件</span>        <span class="hljs-keyword">if</span>(a%i==<span class="hljs-number">0</span>)<span class="hljs-comment">//如果整除</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//扔回false</span>    <span class="hljs-comment">//程序都到这里的话就说明此为素数</span>    <span class="hljs-comment">//否则就被扔回了</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//扔回true</span>&#125;<span class="hljs-keyword">int</span> n,k;<span class="hljs-keyword">int</span> a[<span class="hljs-number">25</span>];<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ans;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> sum,<span class="hljs-keyword">int</span> startx)</span></span>&#123;<span class="hljs-comment">//最重要的递归</span><span class="hljs-comment">//m代表现在select了多少个数</span><span class="hljs-comment">//sum表示当前的和</span><span class="hljs-comment">//startx表示升序排列，以免算重</span>    <span class="hljs-keyword">if</span>(m==k)&#123;<span class="hljs-comment">//如果选完了的话</span>        <span class="hljs-keyword">if</span>(isprime(sum))<span class="hljs-comment">//如果和是素数</span>            ans++;<span class="hljs-comment">//ans加一</span>        <span class="hljs-keyword">return</span> ;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=startx;i&lt;n;i++)        dfs(m+<span class="hljs-number">1</span>,sum+a[i],i+<span class="hljs-number">1</span>);<span class="hljs-comment">//递归</span>        <span class="hljs-comment">//步数要加一，和也要加</span>        <span class="hljs-comment">//升序起始值要变成i+1,以免算重</span>    <span class="hljs-keyword">return</span> ;<span class="hljs-comment">//这一个步骤下，所有的都枚举完了</span>    <span class="hljs-comment">//直接返回去</span>&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);<span class="hljs-comment">//输入</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;a[i]);<span class="hljs-comment">//循环读入</span>    dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">//调用函数</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<span class="hljs-comment">//输出答案</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//结束程序</span>&#125;</code></pre><h1 id="3-广度优先搜索（BFS）"><a href="#3-广度优先搜索（BFS）" class="headerlink" title="3.广度优先搜索（BFS）"></a>3.广度优先搜索（BFS）</h1><h2 id="3-1-基本思想"><a href="#3-1-基本思想" class="headerlink" title="3.1 基本思想"></a>3.1 基本思想</h2><p>广度优先搜索是一种通过逐层遍历所有访问对象，从而找到通过最短节点数到达目标的算法。从一点开始，每当生成一层结点，则将其标记，之前未被标记被搜寻到的结点将继续展开得到下一层的结点，以此类推，直到从起始点可到达的所有顶点都被标记为止。<br><img src="https://img-blog.csdnimg.cn/2020031707313973.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3M3NzQ5NmF6,size_16,color_FFFFFF,t_70" alt="55"></p><h2 id="3-2-实现代码"><a href="#3-2-实现代码" class="headerlink" title="3.2 实现代码"></a>3.2 实现代码</h2><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">BFS</span><span class="hljs-params">(Node&amp; Vs, Node&amp; Vd)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">queue</span>&lt;Node&gt; Q;    Node Vn, Vw;    <span class="hljs-keyword">int</span> i;    <span class="hljs-comment">//初始状态将起点放进队列Q</span>    Q.push(Vs);    hash(Vw) = <span class="hljs-literal">true</span>;<span class="hljs-comment">//设置节点已经访问过了！</span>    <span class="hljs-keyword">while</span> (!Q.empty())     &#123;   <span class="hljs-comment">//队列不为空，继续搜索！</span>        <span class="hljs-comment">//取出队列的头Vn</span>        Vn = Q.front();        <span class="hljs-comment">//从队列中移除</span>        Q.pop();        <span class="hljs-keyword">while</span> (Vw = Vn通过某规则能够到达的节点)        &#123;            <span class="hljs-keyword">if</span> (Vw == Vd)             &#123;   <span class="hljs-comment">//找到终点了！</span>                <span class="hljs-comment">//把路径记录，这里没给出解法</span>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//返回</span>            &#125;            <span class="hljs-keyword">if</span> (isValid(Vw) &amp;&amp; !visit[Vw])             &#123;                <span class="hljs-comment">//Vw是一个合法的节点并且为白色节点</span>                Q.push(Vw);<span class="hljs-comment">//加入队列Q</span>                hash(Vw) = <span class="hljs-literal">true</span>;<span class="hljs-comment">//设置节点颜色</span>            &#125;         &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//无解</span>&#125;</code></pre><h2 id="3-3-例题"><a href="#3-3-例题" class="headerlink" title="3.3 例题"></a>3.3 例题</h2><h5 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h5><p>有一个仅由数字000与111组成的n×nn \times nn×n格迷宫。若你位于一格0上，那么你可以移动到相邻444格中的某一格111上，同样若你位于一格1上，那么你可以移动到相邻444格中的某一格000上。<br>你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。</p><h5 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h5><pre><code class="cpp">#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;iostream&gt;using namespace std;queue&lt;int &gt;xx;queue&lt;int &gt;yy;char w,b;char map[1001][1001];int book[1001][1001]=&#123;&#125;;int step[1001][1001]=&#123;&#125;;int in[1000001][3];int inx;int iny;int n,m;int bfs(int ,int );int i,j;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int t=1;t&lt;=n;t++)    &#123;        for(int p=1;p&lt;=n;p++)                    cin &gt;&gt; map[t][p];    &#125;    int t=1;t&lt;=m;t++)    &#123;            scanf(&quot;%d%d&quot;,&amp;inx,&amp;iny);            if(book[inx][iny]==0)            &#123;                bfs(inx,iny);                printf(&quot;%d\n&quot;,step[inx][iny]);            &#125;            else            &#123;                printf(&quot;%d\n&quot;,step[inx][iny]);            &#125;            //这里发现可以读一个查一个，于是就没有再用整个数组存进来然后重头再扫一次。    &#125;    getchar();    getchar();    return 0;&#125;int bfs(int x,int y)//咳咳！这里是折腾我最久的地方了&#123;     int flag=1;     //flag是因为实在想不到别的好的变量名去存可以到的地点的个数，后来发现flag貌似和sum一样     int nx,ny;     int move[4][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;;     int sum=1;     in[flag][1]=x;     in[flag][2]=y;     book[x][y]=1;     xx.push(x);     yy.push(y);     //这里一定要记得标记起点和将起点的坐标放进队列，这里也看了好久才发现。     while(xx.size()!=0 &amp;&amp; yy.size()!=0)     &#123;                    xx.pop();             yy.pop();     for(int t=0;t&lt;4;t++)      &#123;             nx=x+move[t][0];             ny=y+move[t][1];             w=map[x][y];             b=map[nx][ny];             if(book[nx][ny]==0 &amp;&amp; w!=b &amp;&amp; nx&gt;0 &amp;&amp; ny&gt;0 &amp;&amp; nx&lt;=n &amp;&amp; ny&lt;=n)             &#123;                                                  flag++;                                in[flag][1]=nx;                                in[flag][2]=ny;                                book[nx][ny]=1;                                xx.push(nx);                                yy.push(ny);                                sum++;             &#125;      &#125;      x=xx.front();      y=yy.front();     &#125;     //上面都是简单的bfs，但是记得过程中要记录每一个能到的点。这里的book是不用重置的哦。     for(int u=1;u&lt;=flag;u++)     &#123;             step[in[u][1]][in[u][2]]=sum;     &#125;     //再将每一个成员能到的点的个数分别记录下来！他们能到的个数都一样哦~~     return sum;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
